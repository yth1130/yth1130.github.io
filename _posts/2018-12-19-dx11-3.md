---
layout: post
title: "3. 렌더링 파이프라인(2)"
date: 2018-12-19 19:30:00
description: 정점 셰이더
share: false
comments: true
tags: 
 - directX
---

정점 셰이더(vertex shader, VS) 단계
======
입력 조립기 단계에서 기본 도형을 조립한 후 정점들이 여기로 입력된다.  
**정점 하나를 받아서 정점 하나를 출력**하는 함수.  
화면에 그려질 모든 정점은 이 정점 셰이더를 거쳐간다.  
GPU에서 실행되기 때문에 아주 빠르다.  
변환, 조명, 변위 매핑 등 수많은 특수 효과 수행 가능.  
입력 정점 자료는 물론 텍스쳐, 변환 행렬, 장면 광원 정보 등 GPU메모리에 담긴 다른 자료에 접근 가능.

**로컬 스페이스** : 각각의 모델들이 구축된 기준 좌표계.  
**월드 스페이스** : 모든 모델들이 배치된 전역 공각 좌표계.  
**월드 변환** : 월드 행렬을 이용해 로컬 스페이스에서 정의한 정점들을 월드 스페이스로 배치.
- 이 변환을 하면 모든 물체의 좌표가 동일한 좌표계(월드 공간)을 기준으로 한 것이 된다.
- Q,u,v,w(각각 x,y,z성분을 갖고 w성분은 0인 4원소 벡터)가 월드 스페이스를 기준으로 한 로컬 스페이스의 원점,x축,y축,z축을 뜻하는 동차좌표라고 할 때,  
로컬 스페이스를 월드 스페이스로 변환하는 좌표 변경 행렬 W는  
u<sub>x</sub>, u<sub>y</sub>, u<sub>z</sub>, 0  
v<sub>x</sub>, v<sub>y</sub>, v<sub>z</sub>, 0  
w<sub>x</sub>, w<sub>y</sub>, w<sub>z</sub>, 0  
Q<sub>x</sub>, Q<sub>y</sub>, Q<sub>z</sub>, 1  
이다. 이것은 직관적이지 않다.
- 좀더 흔한 접근 방식은 W=SRT의 형태. 비례행렬 S, 회전행렬R, 이동행렬T를 곱한 것.

**동차좌표(homogeneous coordinate)** : 3차원 벡터에 w성분을 추가한 4원소쌍의 형태. 이 w의 값이 서술하는 것이 점이냐 벡터냐에 따라 달라진다. 0이면 벡터, 1이면 점.

**뷰 스페이스** : 관찰자가 보는 영역을 결정하는 가상의 카메라에 부여된 로컬 좌표계. 카메라 스페이스라고도 한다.
- 카메라는 이 공간의 원점에서 양의 z축을 바라본다. x축은 오른쪽, y축은 위쪽 방향.
	
**뷰 변환** : 뷰 행렬을 이요한 월드 스페이스에서 뷰 스페이스로의 좌표 변경 변환.
- 월드 변환과는 반대의 변환이라 할 수 있다.(월드 스페이스에서 카메라의 로컬 스페이스로 가는 것이기 때문)  
즉 월드 변환에서 쓰이는 월드행렬 W의 역행렬 W<sup>-1</sup>이 월드 스페이스에서 뷰 스페이스로의 변환 행렬이다.
- 일반적으로 월드 스페이스와 뷰 스페이스는 위치와 방향만 다르므로 W=RT라 할 수 있다.  
V = W^-1 = (RT)^-1 = T^-1R^-1 = T^-1R^T ???????? 왜 R^-1 이 R^T인지?
- 역시 직관적이지 않음.
- Q가 카메라 위치이고 T가 카메라가 바라보는 지점, j가 월드 스페이스위 위쪽을 가리키는 단위벡터(상향벡터, up vector, (0,1,0))라 하자.  
카메라의 로컬 z축(w)을 구하고(Q와 T를 이용, 정규화), 로컬 x축(u)을 구한다(j x w 후 정규화).  
마지막으로 로컬 y축을 구한다(w x u).  
~~~
XNA Math라이브러리의 XMMatrixLookAtLH함수.
~~~

**원근 투영(perspective projection)** : 평행선들이 하나의 소실점으로 수렴하는 방식의 투영.  

**프로젝션 변환** : 하나의 3차원 정점을 그 투영선이 2차원 투영 평면과 만나는 점으로 변환하는 변환.

**절두체(frustum, 끝이 잘린 사각뿔)** : 카메라가 바라보는 공간 영역.
- 시야 절두체는 원점과 가까운 평면사이의 거리 n, 먼 평면 사이의 거리 f, 수직 시야각 a, 종횡비 r로 정의할 수 있다.
- 종횡비(aspect ratio) r = 투영 창의 너비 w / 창의 높이 h.  
일반적으로 후면 버퍼의 너비와 높이에 맞춘다.  
- 수평 시야각 β는 수직시야각α와 종횡비 r로 구할 수 있다.
	
- 투영창의 높이를 2로 했을 때.
  - 투영창 너비 구하기 : r = w / h = w / 2 => w = 2r  
  - 투영창 까지의 거리 구하기 : tan(α / 2) = 1(높이의 절반) / d(투영창 까지의 거리) => d = cot(α / 2)
  - 수평 시야각 구하기 : tan(β / 2) = r(너비의 절반) / d = r / cot(α / 2) = r * tan(α / 2) => β= 2 * tan^(-1) * (r * tan(α / 2))
  - 정점 투영 : 점(x,y,z)를 투영 평면 z=d에 투영한 점 구하기
	x' / d = x / z => x' = xd / z = x * cot(α / 2) / 2 = x / (z * tan(α / 2)) [-r, r]
	y'= y / (z * tan(α / 2)) [-1, 1]

**정규화된 장치좌표(NDC, normalized device coordinates)**
- 투영창의 크기가 종횡비에 의존하면 하드웨어가 투영창의 크기가 관여하는 연산을 하려면 하드웨어에게 종횡비를 알려주어야 한다.
- 이런 의존성이 없다면 작업이 더 수월해진다. 
- 투영된 점의 x좌표 성분을 [-r, r]구간에서 [-1, 1]로 비례시킨 후의 좌표를 NDC라고 부른다.
- 단위 변환으로 볼수도 있다. NDC에서의 한 단위는 시야 공간의 r단위와 같다.
- NDC좌표에서는 투영 창의 높이가 2이고 너비도 2이다. 크기가 고정되어 하드웨어는 종횡비를 몰라도 된다.
- 즉 그래픽 하드웨어는 투영된 좌표들이 NDC공간 기준이라고 가정하므로 이 공안을 기준으로 한 투영 좌표를 공급해야 한다.  
x'= x / (r * (z * tan(α / 2))) [-1, 1]  
y'= y / (z * tan(α / 2)) [-1, 1]

**투영 행렬** : 위의 식은 비선형이라 행렬 표현이 존재하지 않는다.
- 선형인 부분과 비선형인 부분(z로 나누는 연산)을 분리해 선형인 부분만 행렬로 표현 가능.
- 원래의 z좌표는 동차좌표의 w성분에 복사되도록 한다.  
투영 행렬 P =  
1 / (r*tan(α / 2)), 0, 0, 0  
0, 1 / tan(α / 2), 0, 0  
0, 0, A, 1  
0, 0, B, 0  
결과는 x,y성분은 위의 결과에서 z로 나눈 부분만 빼고 나오고 z 성분은 Az + b, w성분은 z가 된다.  
각 성분을 w성분(z)로 나누면 투영 변환 완성.  
-> **원근 나누기(perspective divide)**, **동차 나누기(homogeneous divide)**라고 부른다.

**정규화된 깊이 값** : z값이 [0, 1]로 되게 한다. 구간 [n, f]를 [0, 1]로 사상하는 순서 보존 함수 필요.
- 투영 변환의 결과인 A + B / z에서 z가 n이면 0으로, f이면 1로 되게끔 A와 B를 선택.
- A = f / (f - n), B = -nf / (f - n)

**투영 공간(projection space)** = **동차 절단 공간(homogeneous clip space)** : 투영 행렬을 곱한 후, 원근 나누기는 수행하기 전의 기하구조가 존재하는 곳.  
원근 나누기를 수행한 후에 정규화된 장치 좌표공간에 있다고 한다.	

~~~
XNA Math라이브러리의 XMMatrixPerspectiveFovLH함수로 투영 행렬을 얻을 수 있다.
~~~