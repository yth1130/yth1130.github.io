---
layout: post
title: "1. DirectX 11의 기초 - 초기화"
date: 2018-12-15 01:00:00
description: 기본 지식과 초기화
share: false
comments: true
tags: 
 - directX
---
기본지식
=======

**direct3d** : 그래픽 하드웨어를 제어할 수 있는 소프트웨어 인터페이스.

**COM** : Component Object Model
- I로 시작하는 인터페이스들을 이용해 필요한 포인터를 얻는다.
- 해당 포인터를 다 사용한 후에는 Release한다.

**텍스쳐** : 이미지 자료(2차원 텍스쳐) 등을 저장한 것.
- 범용적인 자료의 저장 방법.
- 1차원 텍스처는 자료 원소들의 1차원 배열.3차원 텍스처는 자료 원소들의 3차원 배열. 밉맵 수준이 존재할 수 있다.
- 특정 형식을 따르는 자료만 담을 수 있다.

**자료 자원 형식** : DXGI_FORMAT_으로 시작. 뒷부분은 형식에 따라 나뉜다.

**스왑체인**
- 애니메이션이 깜빡이는 현상을 방지하기 위해서 새로운 장면을 화면 바깥의 텍스처(후면 버퍼)에 그린다.
- 장면을 다 그린 후 전면에 표시한다. 이런 버퍼링을 위해 버퍼가 두개필요하다.
- 두 버퍼를 교환해 화면에 표시하는것을 presenting(제시)라고 한다. 이연산은 포인터만 바꾸기 때문에 효율적이다.
- 두 버퍼는 하나의 swap chain(교환 사슬)을 형성한다.
- IDXGISwapChain인터페이스로 대표된다.
이 인터페이스는 두 버퍼 텍스처를 담고 버퍼 크기 변경을 위한 메서(IDXGISwapChain::ResizeBuffers)와
버퍼 presenting을 위한 메서드(IDXGISwapChain::Present)를 제공한다.
- 두 버퍼를 사용하는 것을 이중 버퍼링이라고 한다.

**깊이 버퍼링**
- 깊이 버퍼(depth buffer)는 이미지 자료를 담지 않는 텍스처의 한 예이다.
각 픽셀의 깊이정보를 담는다. 0.0에서 1.0까지의 값. 1에 가까울 수록 관찰자로부터 멀다.  
- 깊이 버퍼의 원소와 후면 버퍼의 원소는 일대일로 대응된다.
- 새로운 픽셀을 그릴 때 기존에 깊이버퍼 값과 새로 그릴 픽셀의 깊이 값을 비교해 새로 그릴 픽셀의 깊이가 작다면 픽셀을 그리고 깊이 버퍼를 갱신한다.
- 깊이 버퍼도 하나의 텍스처이므로 특정한 자료 형식을 지정해 생성해야 한다.

**텍스처 자원 뷰** : 텍스처를 렌더링 파이프라인에 bind할 때 사용한다.
- Direct3D에서 텍스처를 사용하려면 텍스처 초기화 시점에서 그 텍스처의 자원 뷰(resource view)를 생성해야 한다.
- 렌더 타깃과 셰이더 자원으로 사용하려면 두 개의 뷰를 생성해야 한다. (ID3D11RenderTargetView, ID3D11ShaderResourceView)  
- 자원 뷰는 두 가지 일을 한다.  
하나는 Direct3D에게 자원의 사용 방식(파이프라인의 어떤 단계에 묶을 것인지)을 알려주는 것.  
다른하나는 무형식 자원형식의 구체적인 형식을 결정하는 것. 다른 파이프라인 단계에서 다른 용도로 사용하는 것이 가능하다.
- 어떤 자원에 특정 뷰를 생성하려면 자원을 생성할 때 해당 결속 플래그를 지정해야 한다.  
ex) ID3D11DepthStencilView를 생성하려면 자원을 생성할 때 D3D11_BIND_DEPTH_STENCIL플래그를 지정.

**다중표본화** : 앨리어싱 제거 기법.  
- 초과표본화(하향표준화)는 화면 크기를 가로 세로 2배씩 4배로 키워 렌더링하고 presening할 때 원래크기로 환원(resolving)한다.  
이 방법은 픽셀 처리량과 메모리 소비량이 네배라 비용이 크기때문에 다중 표본화를 사용.
- 4X 다중표본화는 초과표본화처럼 화면 해상도가 4배인 후면버퍼와 깊이버퍼를 사용한다.  
이미지 색상을 픽셀당 한번만 계산하고 그 색상과 부분픽셀들의 가시성과 포괄도를 이용해 최종 색상을 결정한다.  
Direct3D의 다중표본화~~

**기능수준** : 기능성 집합을 정의. 하드웨어가 특정 기능 수준을 지원하지 않으면 더 낮은 기능 수준으로 프로그램을 실행.

--------
Direct3D의 초기화
=======
순서
1. Device와 Device Context생성.
2. 4XMSAA품질 수준 지원 점검.
3. 스왑체인 설정.
4. 스왑체인 생성.
5. 스왑체인의 후변 버퍼에 대한 렌더 타깃 뷰를 생성.
6. 깊이스텐실버퍼와 그에 연결되는 깊이스텐실 뷰를 생성.
7. 뷰들을 출력 병합기 단계에 묶기.
8. 뷰포트를 설정.

**순서1. Device와 Device Context생성.**
- 두 인터페이스는 Direct3D의 주된 인터페이스. 물리적인 그래픽 장치 하드웨어에 대한 소프트웨어 제어기.
- 이 인터페이스를 통해 하드웨어에게 할 일(GPU메모리에 자원 할당, 후면 버퍼 지우기, 자원을 파이프라인 단계에 묶기, 기하구조 그리기 등)을 지시한다.
- ID3D11Device인터페이스는 기능 지원 점검과 자원 할당에 쓰인다.
- ID3D11DeviceContext인터페이스는 렌더 타깃 설정, 자원 묶기, GPU가 수행할 렌더링 명령 지시.
- D3D11CreateDevice함수로 ID3D11Device인터페이스와 ID3D11DeviceContext인터페이스 생성.
- 즉시문맥, 지연문맥~~

**순서2. 4XMSAA품질 수준 지원 점검.**
- ID3D11Device::CheckMultisampleQualityLevels 메서드로 4XMSAA 품질 수준 지원여부 점검.

**순서3. 스왑체인 설정.**
- DXGI_SWAP_CHAIN_DESC구조체의 인스턴스로 스왑체인의 특성을 설정.
	
**순서4. 스왑체인 생성.**
- IDXGIFactory인터페이스로 IDXGISwapChain인스턴스를 생성.	
- IDXGIFactory::CreateSwapChain메서드를 호출.
- DXGI는 Direct3D와는 개별적인 API로 스왑체인설정이나 그래픽하드웨어 나열, 창모드/전체화면모드 전환등 그래픽에 관련된 작업을 처리.

**순서5. 스왑체인의 후변 버퍼에 대한 렌더 타깃 뷰를 생성.**
- 후면버퍼를 파이프라인의 출력 병합기(output merger)단계에 묶으려면 후면 버퍼에 대한 렌더타깃 뷰를 생성해야 한다.
- IDXGISwapChain::GetBuffer메서드로 후면버퍼를 가리키는 포인터를 얻는다.
- ID3D11Device::CreateRenderTargetView메서드로 렌더 타깃 뷰를 생성.
- ReleaseCOM메서드로 다 사용한 후면버퍼를 해제. GetBuffer로 증가한 후면버퍼에 대한 COM 참조 횟수(reference count)를 다시 감소시킨다.

**순서6. 깊이/스텐실 버퍼와 뷰 생성.**
- D3D11_TEXTURE2D_DESC구조체를 채우고
- ID3D11Device::CreateTexture2D메서드 호출.
- 그 다음 ID3D11Device::CreateDepthStencilView메서드 호출.

**순서7. 뷰들을 출력 병합기 단계에 묶기.**
- 렌더타깃뷰와 깊이스텐실뷰를 Direct3D가 사용할 수 있도록 렌더링 파이프라인의 출력 병합기단계에 묶는다.
- ID3D11DeviceContext::OMSetRenderTargets메서드로 묶는다.

**순서8. 뷰포트 설정.**
- 장면을 그려 넣고자 하는 후면 버퍼의 부분 직사각형 영역을 뷰포트라고 부른다.
- D3D11_VIEWPORT 구조체로 뷰포트를 서술한다.
- ID3D11DeviceContext::RSSetViewports메서드로 Direct3D에게 뷰포트를 알려준다. 여러 개의 뷰포트를 사용할 수도 있다.

-------
타이밍과 애니메이션
=======
성능 타이머(performance timer, performance counter)를 사용.